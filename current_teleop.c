/*
Standard Model: FTC Team 9372
Current Teleop Code
(c) January 2015
*/
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S4,     ballSensor,     sensorCOLORFULL)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     leftFront,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftBack,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightFront,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rightBack,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     stomper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    tubeHolderServo,      tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    boxServo,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    tubeGrabberServo,     tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    backwardsModeServo,   tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

task main()
{
    
    //zero lift motor encoder
	nMotorEncoder[lift] = 0;
    
    
	int backwardsDrive = 0; // boolean to store which direction is considered "forwards"
    
	string sColor; // color the color sensor is seeing
    
	int autoStomp = 0;
    
    //variables to store motor values
	int LF = 0, LB = 0, RF = 0, RB = 0;
    
    //variables to store values of joysticks
	int x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    
    //set the tube holder servo to closed
	servo[tubeHolderServo] = 58;
    
    //zero rightBack motor encoder
	nMotorEncoder[rightBack] = 0;
    
	int switchedForwards = 0; // if this is 0, stomper is forwards. if it is 1, lift is forwards.
	//fixes the problem with driving backwards being hard
    
	waitForStart();
    
	while(true) {
		getJoystickSettings(joystick);
        
		// Resets motor values to zero
		LF = 0;RF = 0;LB = 0;RB = 0;
        
		// Get joystick values and set them to 50% original value for calculation/avoiding motor burnout
		x1 = joystick.joy1_x2 * .5;y1 = joystick.joy1_y1 * .5;
		x2 = joystick.joy1_x1 * .5;y2 = joystick.joy1_y2 * .5;
        
        
		
		// Handle Strafing Movement
		LF += x1;RF -= x1;LB -= x1;RB += x1;
		// Handle Regular Movement
		LF -= y1;RF -= y1;LB += y1;RB += y1;
		// Handle Turnign Movement
		LF -= x2;RF += x2;LB -= x2;RB += x2;
		
		if(backwardsDrive == 1) { //adjust motor values for which direction is "forwards"
			int tmp = LF;
			LF = RB;
			RB = tmp;
			tmp = RF;
			RF = LB;
			LB = tmp;
			servo[backwardsModeServo] = 255; //set backwards indicator servo to ON (this should be attached)
		} else {
			servo[backwardsModeServo] = 0; //set backwards to OFF
		}
        
        //Finish applying motor values
		motor[leftFront] = LF;
		motor[rightFront] = RF;
		motor[leftBack] = LB;
		motor[rightBack] = RB;
        
        
		//Gunner Controls lift using right joystick y_value
		if(abs(joystick.joy2_y2) > 10) {
			motor[lift] = joystick.joy2_y2;
			//liftPos = -1;
		} else {
			motor[lift] = 0;
		}
        
        
        //detect which color the color sensor is seeing
		switch (SensorValue[ballSensor])
		{
            case BLACKCOLOR: sColor = "Black"; break;
            case BLUECOLOR: sColor = "Blue"; break;
            case GREENCOLOR: sColor = "Green"; break;
            case YELLOWCOLOR: sColor = "Yellow"; break;
            case REDCOLOR: sColor = "Red"; break;
            case WHITECOLOR: sColor = "White"; break;
            default: sColor = "???"; break;
		}
		nxtDisplayCenteredTextLine(2,sColor); // display color
        
		//If a ball is seen, stomp (balls are WHITE or GREEN)
        
		if(SensorValue[ballSensor] == GREENCOLOR || SensorValue[ballSensor] == WHITECOLOR) {
			motor[stomper] = -50;
			wait1Msec(300);
		} else if(SensorValue[ballSensor] == BLUECOLOR) { //If the blue tape on the stomper is seen, move stomper up
			motor[stomper] = 50;
			wait1Msec(700);
		}
		else {
            //if a ball is not seen and the stomper tube is not seen, allow Driver/Gunner to manual stomp
			if(joy1Btn(6) == 1 || joy2Btn(6) == 1)
				motor[stomper] = 80;
			else if(joy1Btn(8) == 1 || joy2Btn(8) == 1)
				motor[stomper] = -80;
			else
				motor[stomper] = 0;
		}
        
        
		//Driver one manipulates whether the tube holder servo is in position to hold onto or release tube
		if(joy1Btn(5) == 1)
			servo[tubeGrabberServo] = 230;
		else if(joy1Btn(7) == 1)
			servo[tubeGrabberServo] = 100;
        
		//Driver/Gunner control tilt of stomper
		if(joy1Btn(3) == 1 || joy2Btn(3) == 1) {
			wait1Msec(200);
			servo[tubeHolderServo] = (servo[tubeHolderServo] == 58) ? 139 : 58;
		}
        
        
		//Driver/Gunner control state of box servo
		if(joy1Btn(4) == 1 || joy2Btn(4) == 1) // this should probably be removed from the driver's control.
			servo[boxServo] = 0;
		else
			servo[boxServo] = 255; //Box is always closed unless the butten is pressed
        
		//Set which direction is considered forwards
		if(joy1Btn(1)==1)
			backwardsDrive = 1;
		else if(joy1Btn(2)==1)
			backwardsDrive = 0;
        
	}
    
    
}
